"""
Goong Maps Routing Service
Real-world routing using Goong Maps Directions API (like Google Maps for Vietnam)

API Documentation: https://docs.goong.io/rest/directions/
"""

import requests
from typing import List, Dict, Any, Optional, Tuple
import logging
import math

from app.services.route_optimizer import RouteOptimizer

logger = logging.getLogger(__name__)


class GoongRoutingService:
    """
    Service to get real-world routes using Goong Maps API
    """
    
    BASE_URL = "https://rsapi.goong.io"
    
    def __init__(self, api_key: str, optimization_strategy: str = "weighted"):
        """
        Initialize Goong routing service
        
        Args:
            api_key: Goong Maps API key
            optimization_strategy: Algorithm for route selection
        """
        if not api_key:
            raise ValueError("Goong API key is required")
        
        self.api_key = api_key
        self.session = requests.Session()
        self.optimizer = RouteOptimizer(strategy=optimization_strategy)
        logger.info(f"Goong Routing Service initialized (strategy={optimization_strategy})")
    
    def get_route(
        self,
        origin: Tuple[float, float],
        destination: Tuple[float, float],
        vehicle: str = "car",
        alternatives: bool = True
    ) -> Optional[Dict[str, Any]]:
        """
        Get route from origin to destination
        """
        # Validate vehicle type - Goong only supports: car, bike, truck, taxi, hd
        valid_vehicles = ["car", "bike", "truck", "taxi", "hd"]
        if vehicle == "foot" or vehicle == "walking":
            vehicle = "bike"
        elif vehicle not in valid_vehicles:
            vehicle = "car"
        
        url = f"{self.BASE_URL}/Direction"
        
        params = {
            "origin": f"{origin[0]},{origin[1]}",
            "destination": f"{destination[0]},{destination[1]}",
            "vehicle": vehicle,
            "api_key": self.api_key,
            "alternatives": "true" if alternatives else "false"
        }
        
        try:
            logger.info(f"Getting route: {origin} -> {destination} (vehicle={vehicle})")
            
            response = self.session.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            # Check for error responses
            if "error" in data:
                logger.error(f"Goong API error: {data.get('error')}")
                return None
            
            # Check if routes exist
            routes = data.get("routes", [])
            if not routes:
                logger.error("Goong API: No routes found")
                return None
            
            # Parse ALL routes from API
            all_routes = []
            for route in routes:
                try:
                    leg = route["legs"][0]
                    route_data = {
                        "distance_meters": leg["distance"]["value"],
                        "distance_km": round(leg["distance"]["value"] / 1000, 2),
                        "distance_text": leg["distance"]["text"],
                        "duration_seconds": leg["duration"]["value"],
                        "duration_minutes": round(leg["duration"]["value"] / 60, 1),
                        "duration_text": leg["duration"]["text"],
                        "start_address": leg.get("start_address", ""),
                        "end_address": leg.get("end_address", ""),
                        "polyline": route["overview_polyline"]["points"],
                        "steps": self._parse_steps(leg.get("steps", [])),
                        "vehicle": vehicle,
                    }
                    all_routes.append(route_data)
                except (KeyError, IndexError) as e:
                    logger.warning(f"Failed to parse route: {e}")
                    continue
            
            if not all_routes:
                logger.error("No valid routes parsed")
                return None
            
            # Use optimizer to select BEST route
            result = self.optimizer.select_best_route(all_routes, verbose=True)
            
            if not result:
                logger.error("Algorithm failed to select best route")
                return None
            
            # Include other alternatives for comparison
            if alternatives and len(all_routes) > 1:
                result["alternatives"] = [
                    {
                        "distance_km": r["distance_km"],
                        "duration_minutes": r["duration_minutes"],
                        "polyline": r["polyline"]
                    }
                    for r in all_routes if r.get("polyline") != result.get("polyline")
                ]
            
            logger.info(f"Route found: {result['distance_km']}km, {result['duration_minutes']}min")
            return result
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Goong API request failed: {e}")
            return None
        except Exception as e:
            logger.error(f"Error processing route: {e}")
            return None
    
    def find_nearest_bin_route(
        self,
        origin: Tuple[float, float],
        bins: List[Dict[str, Any]],
        vehicle: str = "truck"
    ) -> Optional[Dict[str, Any]]:
        """
        Find nearest waste bin with actual route distance
        """
        logger.info(f"Finding nearest bin from {len(bins)} options...")
        
        if not bins:
            logger.warning("No bins provided")
            return None
        
        # Get routes to ALL bins
        bin_routes = []
        for bin_data in bins:
            destination = (bin_data["latitude"], bin_data["longitude"])
            
            route = self.get_route(
                origin=origin,
                destination=destination,
                vehicle=vehicle,
                alternatives=False
            )
            
            if route:
                bin_routes.append({
                    "bin": bin_data,
                    "route": route
                })
        
        if not bin_routes:
            logger.warning("No valid routes found to any bin")
            return None
        
        # Select best bin based on route score
        best_bin_route = min(
            bin_routes, 
            key=lambda x: x["route"].get("route_score", x["route"].get("distance_km", float('inf')))
        )
        
        result = {
            "bin": best_bin_route["bin"],
            "route": best_bin_route["route"],
            "evaluated_bins": len(bin_routes)
        }
        
        logger.info(
            f"Nearest bin: {result['bin']['name']} "
            f"({result['route']['distance_km']}km, "
            f"{result['route']['duration_minutes']}min)"
        )
        
        return result
    
    def get_optimized_route(
        self,
        origin: Tuple[float, float],
        waypoints: List[Tuple[float, float]],
        destination: Tuple[float, float],
        vehicle: str = "car"
    ) -> Optional[Dict[str, Any]]:
        """
        Get optimized route visiting multiple waypoints
        """
        if len(waypoints) > 23:
            waypoints = waypoints[:23]
        
        url = f"{self.BASE_URL}/Direction"
        waypoints_str = "|".join([f"{lat},{lng}" for lat, lng in waypoints])
        
        params = {
            "origin": f"{origin[0]},{origin[1]}",
            "destination": f"{destination[0]},{destination[1]}",
            "waypoints": waypoints_str,
            "vehicle": vehicle,
            "api_key": self.api_key,
            "optimize": "true"
        }
        
        try:
            response = self.session.get(url, params=params, timeout=30)
            response.raise_for_status()
            
            data = response.json()
            
            if "error" in data:
                return None
            
            routes = data.get("routes", [])
            if not routes:
                return None
            
            route = routes[0]
            
            total_distance = sum(leg["distance"]["value"] for leg in route["legs"])
            total_duration = sum(leg["duration"]["value"] for leg in route["legs"])
            
            return {
                "total_distance_km": round(total_distance / 1000, 2),
                "total_duration_minutes": round(total_duration / 60, 1),
                "waypoint_order": route.get("waypoint_order", []),
                "legs": [
                    {
                        "distance_km": round(leg["distance"]["value"] / 1000, 2),
                        "duration_minutes": round(leg["duration"]["value"] / 60, 1),
                    }
                    for leg in route["legs"]
                ],
                "polyline": route["overview_polyline"]["points"]
            }
            
        except Exception as e:
            logger.error(f"Route optimization failed: {e}")
            return None
    
    @staticmethod
    def _parse_steps(steps: List[Dict]) -> List[Dict]:
        """Parse navigation steps from API response"""
        result = []
        for step in steps:
            try:
                result.append({
                    "instruction": step.get("html_instructions", ""),
                    "distance_meters": step["distance"]["value"],
                    "duration_seconds": step["duration"]["value"],
                    "maneuver": step.get("maneuver", "")
                })
            except (KeyError, TypeError):
                continue
        return result


class StraightLineRouter:
    """
    Fallback router using straight-line distance (Haversine)
    """
    
    @staticmethod
    def haversine_distance(
        point1: Tuple[float, float],
        point2: Tuple[float, float]
    ) -> float:
        """Calculate straight-line distance between two points"""
        R = 6371
        
        lat1, lon1 = math.radians(point1[0]), math.radians(point1[1])
        lat2, lon2 = math.radians(point2[0]), math.radians(point2[1])
        
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        
        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
        c = 2 * math.asin(math.sqrt(a))
        
        return round(R * c, 2)
    
    @staticmethod
    def find_nearest_bin(
        origin: Tuple[float, float],
        bins: List[Dict[str, Any]]
    ) -> Optional[Dict[str, Any]]:
        """Find nearest bin using straight-line distance"""
        if not bins:
            return None
        
        nearest = None
        min_distance = float('inf')
        
        for bin_data in bins:
            dest = (bin_data["latitude"], bin_data["longitude"])
            distance = StraightLineRouter.haversine_distance(origin, dest)
            
            if distance < min_distance:
                min_distance = distance
                nearest = bin_data
        
        if nearest:
            return {
                "bin": nearest,
                "distance_km": min_distance,
                "method": "straight_line"
            }
        
        return None
